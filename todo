СОВЕТИКИ
Нужно начать писать советики по разработке приложений под scage. Типа Best Practices. Постараюсь постепенно пополнять
список новыми советиками

* все action'ы, render'ы итд только в объектах, но не в классах.
--
Мм, спорно же... Ну, то есть, если внутри класса определены action'ы или еще что, значит там полюбас импортирован
соответствующий ScageScreen объект (ну или еще каким извращенным способом присутствует). Таким образом, этот класс
 все равно не удастся использовать в отрыве от объекта, как-то по-левому.. Или потенциальный баг в самом объекте, что
 он не сможет проследить за своевременным удалением action'а и такое сложно отследить... Ну хз.

* все var с модификаторами только private
--
Не актуально, за нас уже подумали. ОКАЗЫВАЕТСЯ, поля в классах всегда имеют самый зверский модификатор private[this], и если
мы выставили для var публичный или протектед модификатор, автоматически генерятся геттер и сеттер. Это оче круто,
на самом деле. Примечательно, что во всем коде scage мне понадобилось всего в двух местах удалить лишние геттеры-сеттеры)

* в трейтах стараться не писать конструкторский код, только def'ы и val'ы

* точка входа в приложение должна наследоваться от ScageScreen (или MultiControlledScreen) с параметром
is_main_unit=true

----------------
Набор методов в Vec, меняющие его внутренние поля - подумать о целесообразности. Многое бы упростилось и мб ускорилось,
но и возможностей для багов больше.

мб завести что-то типа onPhysicsCoordChanged() - чтобы не приходилось в трейсере обновлять координату физического объекта на каждом шаге

Нужно продумать стандартный механизм идентификации клиентов. А то сейчас можно хоть телнетом подключиться, и сервак думает что это клиент
и создает под него игровые сущности и шлет ему инфу. В перспективе мб даже завести некую секурность - идентификацию на основе каких-нить
криптоалгоритмов, чтобы ботов сложнее было написать.

говорят, tcp/ip это не круто, круто - udp. По крайней мере для динамичных игр с
интенсивным сетевым обменом. Надо как-то продумать это и запилить использование
udp наряду с tcp/ip (под настройку например).

запилить функции в NetServer: sendToAllExcept(), sendToAllExceptSync()

продумать механизм опертиавного дисконнекта отвалившихся клиентов. очевидный путь: уменьшить пинг_таймаут, но тогда без конца будут мусорные пинги, которые ни к чему в
тех типах сетевых приложений, которые и сами постоянно что-то шлют. Мб нужно какое-нибудь апи, чтобы клиентские приложения сами могли офлайнов отслеживать и давать команду
на очистку в нужное время.
--
еще можно таймаут очистки от офлайнов запилить под отдельную настройку (net.offline_check_timeout) и уменьшать только ее, а пинг. например, вообще
отключить. еще можно поиметь некий стандартный механизм общения клиента и сервера в начале и в конце. Сейчас сервер вначале присылает accepted, а
в конце disconnect, а клиент у нас весь такой молчаливый. Это и к вопросу об идентификации клиента.

пишут
http://stackoverflow.com/questions/5740906/how-to-check-for-null-in-a-single-statement-in-scala
что это scala-way избавляться везде от null и заменять на Option. Надо просмотреть код scage на предмет такого (например,
net api)

запилить функцию drawTraceLocations() (done!)

перепилить Trace:                           (done!)
trait Trace -> trait TraceTrait
добавить отдельный класс Trace, где changerType = Trace

лоигрование загрузки картинок по аналогии со шрифтами итд

фиксируем версию 0.8 и съебываем на гитхаб! (поросенок Петр, почти (с))

похоже, идея с сортировкой функций рисования при всей своей винрарности не очень применима на практике и нуждается в доработке - потому что в реальных проектах
по сути, видимо будет требоваться всего одна функция отрисовки, выполняющаяся безусловно, и она уже в свою очередь будет решать, что нарисовать, а что нет - таким образом,
порядок рисования нужно будет вычислять другими средствами, предложенный механизм не годится. Есть несколько путей решения проблемы:
* впиливать динамически заполняемый мап allow_render
* разобраться с опенгльным depth-buffer. Я как-то уже пробовал, у меня не заработало, и я забил разбираться. Мб надо дожать это. На первый неискушенный взгляд это решение
 кажется лучше, потому что встроено в потроха opengl, типа ничего и делать не надо (а все есть).

phys2d, который используется в качестве физ.движка в scage, не развивается с 2008 года. В целом, он ничего, но есть
небольшие проблемы, например, такой комент в методе step() класса World:
Currently anything other than 1/60f as a step leads to unpredictable results - hence the default step
fixes us to this step
из-за чего в своей обертке ScagePhysics я пилю вот такой космический костыль:
def step() {
    _physicals.foreach(_.clearTouches())
    for(i <- 1 to _dt) {
      world.step()
      for(p <- _physicals) {
        p.updateCollisions(world.getContacts(p.body))
      }
    }
}
потому что дефолтного шага в 1/60 сильно не хватает (5/60 выглядит норм).
В общем, есть альтернативы среди физ.движков:
* JBox2D http://jbox2d.org/, http://code.google.com/p/jbox2d, в активной разработке, последние коммиты за 30 января 2012 (на текущий момент,
8 февраля). Доступен через мавен в репозитории sonatype (https://oss.sonatype.org/index.html#nexus-search;quick~jbox2d)
* JBullet http://jbullet.advel.cz/, java-порт сишного движка Bullet. В плане исходников и активности разработки менее вразумительный,
в частности, оно, кажется, не умеет в мавен. И не 2д к тому же

возможное перманентное накопление  сообщений в акторах сетевой подсистемы. Подумать об этом
--
в акторах сетевой подсистемы надо запилить событие status или state - чтобы по нему отдавал всякую инфу о себе, в том числе количество сообщений в майлбоксе.

подумать над множественными начитками restitution в физическом движке

переделать контроллер (^^) с использованием partialFunction:
controls {
  case "KEY_W" => (wanna_go_up = true; wanna_go_up = false)
}
пока просто подумать об этом, концепт типа

придумать доработку или воркэраунд к трейсеру или к чему-нибудь, чтобы уметь рисовать непрерывную картинку на границах областей при увеличении - чтобы не было "телепортаций"
при пересечении края экрана
--
в своем простейшем виде доработка заключается в отрисовке еще восьми копий основного кадра со смещениями на один
экран вверх, вниз, в стороны и по диагоналям. Фпс при этом падает в среднем в два раза.

мб все проперти которые начитывает движок, поместить в lazy val в ScageProperties, и брать их оттуда.
--
по моему, не нужно

придумать как вписывать версию в джарник в манифест и как ее забирать оттуда. Чтобы не вписывать номер версии в 100500 местах (в pom.xml и в файле пропертей - для отображения в заголовке окна),
а только в одном (в pom.xml)
--
аналогично можно попробовать поступить с именем

попробовать вытащить из phys2d алгоритм такого-то крутого collision detection'а

уметь задавать window_width, window_height в коде (по умолчанию берутся из пропертей) (done, вынесены в качестве параметров в ScreenApp, по умолчанию по прежнему берутся из пропертей)

net api, рассмотреть юзкейсы:
* ввести с клавиатуры порт и стартовать на нем сервер. Остановить сервер по событию с клавиатуры, потом начать снова на новом (заданном) порту (done, теперь вроде должно уметь так)
* ввести с клавиатуры брл и порт для подключения и стартовать клиент. По событию с клавиатуры отключиться, затем подключиться к новому хосту. (done)

Все-таки попробовать уменьшить количество импортов (done! впилил таки ScageLib, уряяя!!!))

сделать NetServer уметь сообщать что он закончил работу для корректного выхода (чтобы можно было подождать, пока все
треды завершатся). (done, сделал дополнительные методы sendSync() - синхронные посылалки, а также сделал метод disconnect() тоже синхронным,
то есть основном поток будет ждать сигнала его завершения и только после этого продолжать).  (done)

сделать Renderer, который object и Renderer, который trait - одной структурой, сделать в ней метод initgl с модификатором
private[scage], запускать его из main в ScageScreenApp... (хм, короче я разобрался с этим, done)

или все-все трейтами переделать... Ладно, если только понадобится.

Несколько статей про сетевой фреймворк Netty и технологию NIO, на которой он основан
http://habrahabr.ru/blogs/java/136456/
http://habrahabr.ru/blogs/gdev/136765/
критикуется архитектура сервера, когда на каждое подключение создается по потоку (а я еще и по два хотел, на ввод и вывод) -
поскольку переключение между потоками в яве удовольствие дорогое, нужно стараться обходиться как можно меньшим их количеством.
В общем, мб сетевое апи надо на этом Netty переписать
--
допилил через акторы, должно быть годно, стопицот тредов не создается, так что нахуй нетти пока что.

Доработка интерфейсов: контролы. Тег <control>. Область в виде многоугольника (задается координатами).
При клике на него генерится событие, и по этому событию можно что-нибудь сделать. Пока концепция.

В net api может быть надо еще делать по потоку (актор) на отправку сообщений. То есть на сервере на каждого клиента два
потока: на прием и на отправку, и на клиенте два аналогичных потоков. А то отправка немного тормозит.
Еще надо сделать сервер и клиент не быть синглтонами. В принципе все легко, можно сделать аналогично трейсерам. Параметров реально мало,
четыре штуки всего, проблем никаких не вижу. Разве что отдельно запилить возможность динамически выбирать незанятый порт -
вот это будет чуть посложнее. Но это можно на потом оставить.
--
В идеале, конечно, лучше бы доделать совсем ынтерпрайзно: когда отправляем/принимаем очередное сообщение, забираем из пула
новый тред, и он продолжает слушать. Когда тред закончил отправлять/принимать - возвращаем в пул. Количество тредов в пуле можно задавать настройкой.
Будет такой крутой доморощенный томкат =)
--
эта ынтерпрайзность впилена в Scala, "акторы" называется =) Переделал под них сетевое апи.

Перепилить все подсистемы, чтобы наряду с начиткой из ScageProperties умели принимать настройки напрямую в виде параметров.
Чтобы типа альтернатива была. Это в частности касается Renderer, ScagePhysics и net api. (хм, вроде везде done)

ScageProperties: придумать что-нибудь, чтобы источником пропертей был не только файл, а что угодно (например, принимать проперти по сети).
Это пока типа концепции.

проперти: парсить Vec, ScageColor и State. Уметь в формулы плюс запоминание констант (последнее касается также ScageXML). (done)

State не умеет в Int, парсит из json во float, с этим можно что-то сделать, по идее. Алсо надо бы перепилить формат, чтобы умел:
{blabla:"pewpew"}, наряду с {"blabla":"pewpew"} (типа строковый ключ в json необязательно заключать в кавычки)
--
ключ в формате json всегд надо в кавычки брать. Насчет парсинга в int пока забил - а что если очередное значение оказалось целым,
а на другом конце ждем float? Типа не угадаешь, так что пусть будет что-то одно (float)

доработка ScageId:
сделать объектом (забить на класс), в нем два метода:
def nextDisplayListId:Int
def nextId:Long
проблема с дисплей_листами, что opengl принимает для них int и не желает long, но остальным участкам кода лучше бы long,
он гораздо больше чисел содержит, а переполнение количества операций свыше двух миллиардов вполне возможно. Хотя в довершение
надо бы сообразить корректную ротацию айдишников при переполнении или хотя бы эффективный fast-fail - чтобы приложение
сразу обсиралось при превышении. А так это все все равно ненадежно.
--
эта проблема остро не стоит, ну и хрен с ней

мб написать свою парсилку пропертей, чтобы она парсила их в объект State
--
да, но зачем? (с)

Снова появилась идея завести один глобальный импорт, чтобы не импортить каждый раз кучу всего. Если коротко, и без
деталей реализации, это может быть объект ScageApp, от которого надо унаследовать трейты:
import net.scage.handlers.Renderer._
import net.scage.support.ScageColors._
import org.lwjgl.input.Keyboard._
import net.scage.support.messages.ScageMessage._
import net.scage.support.messages.ScageXML._
import net.scage.support.ScageProperties._
ScageId._
Но трейты надо сначала аккуратно написать... В общем, есть о чем подумать           (done! ScageLib!)

Включить в Scage:
http://code.google.com/p/http-bot/source/browse/trunk/src/su/msk/dunno/httpbot/support/Conn.java
http://code.google.com/p/http-bot/source/browse/trunk/src/su/msk/dunno/httpbot/support/parsers/HtmlParser.java
http://code.google.com/p/http-bot/source/browse/trunk/src/su/msk/dunno/httpbot/support/parsers/FormParser.java
для взаимодействия с http. Парсеры, конечно, лучше накарябать свои, но встроенный в Scala xml-фреймворк,
к сожалению, скорее всего не подойдет для html(

сжатие сетевого трафика. В перспективе - шифрование (опциональное, ессно). Причем, сжатие придется писать самостоятельно, потому что
встроенный в жабу gzip немножко не так работает как нам нужно (требует закрывать канал)
--
Есть такая гугловая либа snappy: http://code.google.com/p/snappy-java/, думаю заюзать ее, но пока не до конца разобрался:
http://groups.google.com/group/xerial/browse_thread/thread/8bc9d36c810eda72?hl=en

ШкагеПропертиш НЕОБХОДИМО сделать трейтом!!
--
идея все-таки фейл, потому что бессмысленно это. Ну да, ScageApp теперь носитель настроек, и клиентский код может брать настройки у главного
окна приложения. Круто. Но неклиентский а библиотечный мой код срать же хотел на ScageApp, ведь это класс, а не объект. А настройки моему
библиотечному коду точно также нужны. Так что искать он их будет продолжать в объекте ScageProperties, и никуда от этого не деться.
Ментальный онанизм последней пары дней привел меня к тому что теперь есть один объект ScageProperties, который начитывает имя файла с
настройками из системной проперти -Dscage.properties. Если она отсутствует, используется имя scage.properties. В таком варианте мы полностью
гарантируем наличие уникальность и иммутабельность объекта с настройками для приложения: нет никаких препятствий к его инициализации, и никто
его никогда не перезапишет.
Минусы: если в джарнике есть на самом деле несколько программ, и каждая использует свой файл с настройками, чтобы все правильно
запустить, теперь нужно в строке запуска указывать еще и -Dscage.properties, а раньше достаточно было просто другое имя запускающего
класса указать - имя нужной ему проперти было вписано в параметры конструктора. Может можно как-то научить либу понимать какой файл
какому классу нужен? Например, уметь начитывать имя класса, из которого взята текущая точка входа
и искать файл <имя_класса>.toLowerCase+".properties". Но зато теперь можно удобно подкладывать разные файлы настроек проге, просто меняя
строку запуска, без перекомпиляции. Хз, правда опять же, нужно ли это.

попробовать все же еще разок сделать main unit единственно возможным в системе, и чтобы с него начинался запуск приложения (в нем точка входа) и отложенно вызывался run(), чтобы
самостоятельно его вызывать не надо было (посмотреть, как это сделано в трейте App).

еще апдейт контроллера: вынести отслеживание событий по нажатию кнопок клавиатуры и мыши (was_pressed, last_pressed_time) в объект, чтобы эта инфа была независима от текущего
запущенного экрана и была общей для них всех. В текущей реализации, если, например, по нажатию на какую-либо кнопку осуществляется переход в новый экран, и в нем, в свою очередь по этой же
кнопке осуществляется выход - мы сразу выйдем обратно. Данная доработка должна поправить этот баг.

апдейт контроллера: события по нажатию нескольких клавиш (ctrl-Z, shift-C итд)

мб избавить от ScageMessage и все методы перетащить в Renderer? Хотя нах надо...
--
обратное предложение: сделать трейтом! мм, тоже фейл же...

мб вынести ScageColor в отдельный файл, и все три файла (ScageColor, ScageColors, ScageColorTest) отправить в отдельный пакет colors

Придумать стандартный способ останавливать приложения на основе Scage (без графического интерфейса). Я голосую за какой-нибудь веб-интерфейс или типа того.
--
а вот можно еще так:
val sc = new Scanner(System.in)
и на каждом шаге:
if(sc.hasNextLine) {
    val line = sc.nextLine().trim()
    line match {
        case "exit" | "quit" => Scage.stopApp()
        // more cases here...
        case _ =>
    }
}
правда, Scanner и всякие там hasNextLine() на первый взгляд не выглядят легкими и дешевыми, так что мб лучше эту технику оставлять опциональной на совести приложений, которым такое
действительно надо (например, графическим такое нах не надо, имхо).

добавить в ScageProperties парсилку арифеметики, дописывать ей в константы все вводимые ключи, чтобы их тоже можно было использовать.
реализовать ввод значений Vec и ScageColor

Переписать ColoredString через комбинатор парсеров (главным образом, чтобы поучиться его использовать).
--
Хотя наверное не получится: текущая реализация не context-free (если стоит слеш - не делать color switch) и отказываться от этой фичи не хочется

сетевая часть: перепилить с синглтонов на классы, чтобы была возможность стартовать в одном приложении несколько
серверов/клиентов. Реализовать companion objects - в них запилить текущий порт - увеличивать его на 1 при старте
очередного сервера/клиента, либо при эксепшоне

сетевая часть: запилить крутой парсер json (готовый, из стандартной библиотеки или сторонний, в крайнем случае самому
написать, прочитав главу Parcers из "Programming in Scala, 2nd edition"), чтобы был такой же удобный, как для xml.

сетевая часть: периодические сообщения keepAlive с заданным интервалом (меньше checkTimeout), чтобы не зависеть от
клиентского кода в плане посылки сообщений. Тогда можно поощрять checkTimeout (сделать ненулевым по умолчанию)

удаление клавиш

продумать:
* гарантии инициализации пропертей (проперти в виде трейта?)
* независимость рендера от пропертей (передача нужных вещей в виде параметров в функцию инициализации)
* независимость ScageMessage от пропертей
* логирование запуска юнитов
* трейты Renderer и ScageController получились неотделимы от Scage, отдельно их не получится использовать. Подумать, насколько
это плохо.
* реально ли делать рестарт приложения просто вызовом init (без exit) - тогда можно было бы избавиться от
дополнительного dispose. если же это нереально - запилить функцию restart:
def restart() {
  exit()
  init()
}

надо придумать и написать PerformanceTest

сделать профиль noscagelogo, и в нем собирать либу без логотипа Scage. По умолчанию собирать с логотипом. От
настройки scage.logo в Renderer избавиться.

всегда явно писать тип возвращаемого значения

проставить в нужных местах final и sealed

полностью делать интерфейс экранов в xml, как в андроиде. Продумать язык описания интерфейса.
--
пример xml:
<interfaces>
    <interface id="player.stats" x="20" y = "300" xinterval="5" yinterval="20">
        <row id="player.health" x="20" y="300">
            HP: $0
        </row>
        <row id="player.energy" x="20" y="300">
            Energy: $0
        </row>
        <row />
        <row id="player.defence">
            Def: $0
        </row>
        <row id="player.infection">
            Infection Level: $0
        </row>
    </interface>
</interfaces>
в строчках вместо message_id будут подставляться соответствующие строки из файлов со строками
Вызов из кода:
interface {
  ScageMessage.printStrings(ScageXML.xmlInterface("player.stats", 100, 50, 50, 0), 300, 400, 20)
}
100, 50, 50, 0 - значения, которые следует подставить в строчки вместо знаков вопроса. Здесь такой
момент, что строчки вообще говоря могут иметь произвольное количество знаков вопроса и надо скармливать каждой строке
из этого набора параметров только то, что имеет отношение к ней.
20 - межстрочное расстояние. xmlInterface() возвращает массив строк, они печатаются одна под другой функцией
printStrings(), которая принимает массив строк
--
мб передавать в тегах row также аттрибут message:
<row message_id="player.defence" message="Defence: ?" />
и использовать эту строку согласно какому-нибудь критерию (типа если по айдишнику найти не удалось/айдишника нет)
--
придумать как задавать в xml значения координат через функции от размеров окна (типа резиновый интерфейс) и относительно
положения других интерфейсов
--
в файлах строк мб тоже запилить поддержку аттрибутов координат и цвета
--
насчет задания в пропертях и xml всякого через функции от размеров окна итд - можно впилить самописные парсеры с помощью
встооенного в скакалку генератора парсеров (глава 33 "Programming in Scala, 2nd edition")

перепилить функции-удалялки через няшное collections api (done, перепилено вроде. Во всяком случае, все эти места уже основательно
переебашены и не один раз)

в трейсерах:
getState -> state (done)
traces_in_point -> traces_points (done)

point_matrix -> изменить тип: Array[ArrayBuffer[T]]
--
не годится, придется делать toList в методах, отдающих куски из point_matrix (прям ArrayBuffer-то стремновато отдавать)

http://www.scala-lang.org/node/10473
По ссылке скакалочные изменения в версии 2.9.1
Это надо внимательно прочитать и по возможности впилить в scage, куда надо.

Например, паралелльные коллекции. Это ведь круто?

The App Trait, The DelayedInit Trait - вот мне очень хочется избавиться от обязательного def main(args:Array[String]) {run()}
в объекте-главном экране. В идеале это должно быть что-то такое, что мы пишем весь инициализированный код в нашем
клиенстком объекте, а при запуске, будет вызван он и потом run(). И еще надо чтобы учитывалось, что наследник
ScageScreen может не обязательно быть объектом и тогда чтобы в нем не было ни main, ничего такого.

New methods in collections:
collectFirst, maxBy, minBy, span, inits, tails, permutations, combinations, subsets


можно запилить в init нечто вроде проверки: после отработки всех init-функций мы подсчитываем количество экшонов,
рендеров и интерфейсов. Если количество чего-нибудь увеличилось с последнего запуска инит, отдаем ворнинг с
информацией, чего стало больше. По идее, повторные вызовы init означают перезапуск приложения, то есть по идее все
 в нем должно вернуться к исходному состоянию. Если чего-то стало больше - где-то прога не удаляет за собой, и это
 может привести к переполнению, тормозам итд.

Я прочитал в книжке про ковариантность и контравариантность, и теперь можно подумать, надо ли запиливать что-то
такое в трейсерах

Круто! Оказывается, текущая архитектура контроллера не позволяет добавлять несколько событий на одну клавишу, например,
как-нибудь так:
  key(KEY_1, onKeyDown = println("1!"))
  key(KEY_1, onKeyDown = println("one!"))
отработает только последнее!
С кнопками мыши и другими ее событиями ситуация немного отличается, но работает тоже нестабильно.
---
мб пойти в обратную сторону и запилить возможность на каждую кнопку клавиатуры/мыши, на мышиные
движения/перетаскивания и колесико вешать ровно одну функцию. Повторное добавление перезаписывает текущую

Сделать, чтобы окошко по центру экрана запускалось (done, хотя возможны траблы на мультимониторной системе)

Одноразовые самоудаляющиеся экшоны. Экшоны запускающиеся с задержкой (типа синтаксический сахар такой. И то и то сейчас
может быть реализовано средствами движка).
--
пока неактуально

Сделать объект-компаньон-фабрику для ScagePhysics. Пусть будет апи, похожее на те, что предоставляют объекты коллекций:
val physics = ScagePhysics(ball, floor, left_wall, right_wall, roof, table)
типа оно нам сделает physics и сразу туда добавит нужное. Подумать аналогично про трейсеры.

Доработать апи в ScagePhysics в части касающейся регистрации касаний-столкновений. Вроде phys2d умеет определять точку
касания, надо ее отдавать. Важно же знать не просто, что тела коснулись, а каким они местом коснулись (например,
ударились об стенку в процессе падения, или таки уже ебнулись об пол и пора умирать).

physicals в ScagePhysics - сделать ArrayList
--
или ArrayBuffer, а чо

Renderer: мб scale тоже сделать функцией?.. Подумать о производительности функций center() и window_center()
window_center() особо не используется, кажется он использовался в Blamer только..
Мб предусмотреть два режима: когда эти штуки - изменяемые переменные, и когда функции...
--
этак и backgroundColor и color можно запилить функциями... В общем, серьезно подумать о целесообразности
--
гыгы, нее, низя scale сделать функцией. Иначе будет обсираться более простой юзкейс:
key(KEY_ADD, onKeyDown = {scale += 1})
типа по нажатию на плюсик увеличить масштаб. Если scale будет функцией, то эта функция:
{scale + 1}
будет вызываться каждый такт, в результате после нажатия на плюс картинка начнет непрерывно приближаться.
Воркэраунд от этого выглядит более херово:
private var my_scale = 1
scale = my_scale
key(KEY_ADD, onKeyDown = {my_scale += 1})
три строчки вместо одной. Аналогичные возможные траблы с color и backgroundColor. С другой стороны, с текущим апи,
если нам надо, чтобы масштаб изменялся в зависимости от чего-то, мы пилим что-то такое (пример из проекта Uke):
action {
  scale = if(Uke.coord.y - fartherst_coord.y > screen_height/2) screen_height/2/(Uke.coord.y - fartherst_coord.y) else 1
}
примерно такое же было бы написано, если scale - функция:
scale = {
  if(Uke.coord.y - fartherst_coord.y > screen_height/2) screen_height/2/(Uke.coord.y - fartherst_coord.y) else 1
}
как-то так, кароч

ScagePhysics: изменяемый dt (done)

GRAY и DARK_GRAY надо бы местами поменять (done)

подумать над усложнением схемы работы: предусмотреть возможность перезапуска. Изначально подразумевалось, что код в списке
exits будет вызываться только при окончании работы приложения. Но конечно же суперудобно сделать возможность перезапуска
игры без выхода из приложения, тем более что это достигается практически нахаляву связкой exit(); init();
Проблема в том, что в exits может содержаться код, освобождающий ресурсы насовсем, так что последующие init() и run() обосрутся.
Конечно, не до конца понятно, нужен ли такой код под ява-машиной, все равно, при выходе jvm освободит все...
Вощем как вариант можно запилить еще один список функций, только название для него пока не придумал

Вообще кастомиазция процесса старта приложения и его завершения - отдельная тема, но пока не актуальная. Пока:
слово Loading..., потом логотип движка, потом логотип игры, если есть или вступительная фраза (имя разработчика например),
дальше собственно игра. Показ логотипов и фраз все по 1 секунде, фразы пишутся слева сверху зеленым цветом главным шрифтом.
После игры - слово Exiting...

апгрейд парсилки xml:
пусть принимает еще произвольные аттрибуты, например цвет сообщения, позиция, пауза перед выводом итд. Пусть функция xml()
возвращает json со всеми этими данными и из него уже можно будет нужно вытаскивать

написать функция color:String -> ScageColor (done)

настройка id.start не нужна, потому что нет никакого смысла ее менять, и даже сейчас к этому есть препятствия:
она должна быть не меньше 10000. Пусть она просто будет 10000  (done)

drawRect и drawFilledRect принимают координату и считает ее центральной! Надо еще чтобы был левый верхний угол, как обычно. (done)
--
старые функции переименованы с добавлением префикса Centered. Обратную совместимость я в гробу видал, притом что проектов
все равно никаких нет пока :3

баг с отрисовкой физических полигонов закрашенными мнгоугольниками (функция drawFilledPolygon)

action'ы, которые не тормозятся паузой. Сейчас есть настройка pause.global: если она true, все экшены останавливаются   (done)
на паузе, если false - никакие не останавливаются, и можно там дальше в коде нужных экшонов предусмотреть, влияет ли на
исполнение пауза или нет. Мб вынести эту логику на уровень движка, чтобы были actionNoPause и обычные. Тогда можно
настройку pause.global выкинуть.
--
Аналогично можно предусмотреть влияние паузы на рендеры и на нажатие клавиш.

drawPolygon не имеет параметра color, ай-я-яй (done)
--
орлы? тащем-та просто не было метода, принимающего List в качестве аргумента. Аналогично допилил для drawFilledPolygon

принудительный показ ололологотипа движка (done)

аналогично drawPoints - drawLines (done)

написать апи для проигрывания анимации
--
надо сначала подумать, как бы такое апи могло выглядеть. Хотя можно, как я обычно делаю: написать под определенные нужды,
и если в следующем приложении написанного не хватат, допиливать под него итд.
--
предварительно соснул хуйцов. предложенный вариант апи менее гибкий, чем текущий, через переменную current_frame,
один экшон и один рендер. Надо этот юзкейс как-то весь годно формализовать в один периодический метод.

мелкие оптимизации:
метод removeTrace/removeTraceById (один типа, чтобы не было лишнего foreach), итд
--
тогда и для экшонов что ли такое пилить? я ебанусь же.

подумать на досуге о возможности переполнения айдишников и возможном замедлении работы при логировании
их генерации (в режиме дебаг, при добавлении новых трейсов, например)

начать ботать Java Web Start. В перспективе это должно стать профилем в pom.xml (done)
--
крутота!

новый метод в трейсере: removeTraceByPoint/removeTraceByCoord
--
необходимость пока под вопросом

сообщение в логе при постановке/снятии с паузы (done)
--
нужно например за тем, чтобы иметь возможность все же отслеживать состояние "на паузе/не на паузе", даже
если в интерфейсе это нигде не отображается никак (клиентский разработчик может в программе нигде не помечать состояние паузы)

outsidePoint(...) -> point(...)
--
нее: метод point из CoordTracer перенести в ScageTracer (done)

мб переписать методы типа drawPolygon итд, принимающие произвольное количество координат: сначала цвет,
потом координаты. Это избавит от дополнительного метода (вроде)

допилить drawPoint чтобы принимал список точек (done)
--
метод drawPoints


В ScageMessage добавить методы принимающие Vec вместо float, float
--
дописать в ScageMessage методы print*, принимающие Vec

сделать клавишу "any key" =) (done)

Возможность задания периодичности работы action'ов by-value значением, то есть возможность менять ее на ходу  (done)
--
Сделано. Оставлен предыдущий вариант - статичный период между выполнением action'ов: actionWithStaticPeriod
Благодаря опциям компилятора он даже может быть немножко оптимизированный..)

Возможность передавать State в событийном фреймворке в ScageScreen
--
снабдить логами событийный фреймворк

мб все настройки, начальные параметры вывести в *.properties. Тогда все можно переписать трейтами..
--
тогда будут траблы, если например в клиентском приложении требуется два трейсера в одном классе итд
и вообще, трейт - это если все-таки нужны какие то абстрактные методы

trait ScageTracer
--
фейл. Нельзя иметь одноименные trait и класс. Так что уж лучше класс

Trace extends State
просто и гениально :3
--
свои подводны камни тут тоже есть. Вызов getState начитывал каждый раз в State нужные параметры, и таким образом их
актуальность гарантировалась. Сейчас ничего такого не гарантируется. Более того, любой может сделать любой put в trace!
--
Полный фейл. Устранение подводных камней чересчур усложняет код движка. Откатываюсь назад

pointMatrix --> createMatrix   (done)
--
удалил совсем
--
запилил initMatrix

продумать еще раз добавление action от условий:
условие выполнения action, или период между выполнениями, условие удаления. события при удалении... (done)
--
реализовал просто период между выполнениями, но он может динамически меняться

----------------

RoadMap
v0.5
* physics перенести в support, сделать по аналогии с tracer. До меня внезапно дошло, что в чем-то эти две
структуры весьма схожи. (done)
* переименовать --> в более простое addPhysical (done)
* newtracer перенести в tracer, tracer удалить (done)
* Переименовать базовый класс Tracer в ScageTracer (done)
* В tracer в функции traces добавить отдельные аргументы rangex и rangey (вместо общего range по обоим осям
сейчас) (done)
* Также добавить функцию, возвращающую объекты только с заданной точки (done)
* Поправить баг в updateLocation - если trace.id не был добавлен и не существует в traces_in_coord (done)
* В Renderer в методы draw* добавить аргумент _color, равный по умолчанию текущему цвету. (done)
* добавить функционал по вводу строк (отдельное окошко на свинге с простым текстовым полем, ввод по ctrl-enter)
* Добавить метод, рисующий точку (хочу себе навороченный бейсик)) (done)
* сообщения в логах при удалении операций из ScageScreen (done)

----------------

В движке есть следующие компоненты:
ScageScreen
Controller + Renderer + ScageColors + Keyboard + Mouse
ScageProperties
ScageMessages
NetServer + NetClient
Tracer
ScagePhysics
Постараться, чтобы они не зависили друг от друга, чтобы каждый из этих комопнентов можно было использовать отдельно от
движка.
--
мб допилить, чтобы можно было все параметры задавать как параметры (некоторые сейчас можно только через
файл .properties)

есть operation_id - для скринов и рендеров, есть trace_id - для трейсов и есть disaplylist_key - для дисплейных списков.
последний начинается с 10000 в качестве воркэраунда для одного шняги. Код практически одинаковый.
Мб сделать единый счетчик для всего вообще.              (done)
--
и перефигачить в Long
--
сделано. Long не удалось из-за дисплейных списокв

main screen - сделать единственным в системе, или оставить текущее положение? Вариант ТЗ:
при создании объекта ScageScreen в качестве параметра передавать имя. Первый созданный скрин станет main, для него
будут начитаны переданные проперти. Если проперти не переданы, пытаемся прочитать файл "имя скрина".toLower+".properties"
Главный скрин сейчас по сути - если для него вызвать stop, закрывать программу полностью. В принципе можно сделать программу
без мейн скрина (все скрины - не мейн), и программу с несколькими мейнами. Только смысл? Аналогично с пропертями: можно
переначитывать разные файлы несколько раз в программе в зависимости от. Другое дело, что это можно сделать и безотносительно
к системе скринов..
В общем, первый запущенный скрин становится мейном. Мейн в приложении может быть только один. Если мейн закрылся, приложение
в целом тоже. Относительно мейна начитываются проперти
--
переусложнения и ненужные ограничения, пока отказался

система эвентов в ScageScreen: onEvent(HERO_DIES) {...}, callEvent(HERO_DIES) итд     (done)
--
реализовал, но пока так и не придумал, где это применить. Коды эвентов - строковые константы

удалять рендеры (мб и контролы)      (partly-done)
--
сделал удаление рендеров. про контролы пока непонятно, нужно ли

su.msk.dunno -> net.eredory

продумать:
  * поставку в виде web start
  * поставку в виде апплета
  * продумать сетевой режим через интернет

В общем, мб все отдельные сущности поставлять в двух видах: синглтонами и классами
Например, ScageMessages - классом, чтобы можно было в одном приложении юзать разные шрифты разных размеров итд

Также мб сделать реализации некоторых вещей сразу встроенными в скрины (типа ФизиксСкрин, НетСкрин)
Возможно, что-то можно сделать также трейтами, чтобы еще удобнее было собирать приложение как конструктор
из компонентов

сделать сетевые сущности синглтонами или классами?
  плюсы синглтонов: удобнее синтаксис, можно статически импортить содержимое NetServer/NetClient, и сразу писать
  предметный код, не создавая никаких объектов. Также, более чистенько выглядит взаимодействие
  NetServer - ClientHandler (не надо соображать, выносить ли порт, макс_клиентс, и чек_таймаут в отдельный
  объект, начитывать из файла, или задавать параметром для каждого класса НетСервер и передавать
  клиентхэндлеру нужный ему чек_таймаут...)

  плюсы классов: шире возможности. Можно создавать много разных серверов и клиентов на разных портах и работать
  со всеми одновременно. Вопрос, нужно ли это. Ладно, если будет нужно, перепишу.

запилить режим работы без графики

сделать нормальный общий Logger, который принимает by-name параметры и делает проверку isDebugEnabled итд
--
подумать над вменяемым, красивым и производительным логированием
--
добавить в него возможность продолжать писать лог на той же строке

переименовать в Renderer: createDisplayList -> image, createAnimation -> animation (done)

Раз уж удаление операций вроде фурычит, мб придумать какой-нить механизм самоудаления операций... (done)
--
сделал метод currentOperaion в объекте ScageScreen - возвращает id текущей операции. Таким образом операция может
прочитать его и удалить, удалив таким образом себя

в ScageScreen добавить функции, принимающие списки айдишников операций и удаляющие соотв операции (done)

придумать dsl для парсинга State
--
Нужен более простой синтакисис работы с классом State. JSON-like стиль в целом хорош, но тоже может стать болью в
заднице, когда мы спускаемся на более низкие уровни вложенности. Кроме того нужно продумать задание правил и
зависимостей между значениями внутри State (возможно не в рамках Scage, возможно только в Blamer)

дописать в tracer методы, возвращающие случайные координаты (done)
--
добавить в randomPoint/randomCoord условие, по которому производить генерацию
--
подумал и решил, что это лишнее, потому что скорость работы этих функций более не будет гарантированной
лучше решать проблему отсеивания нужных случайных позиций средствами клиентского приложения (как в Snake)

дальнейший рефакторинг: избавиться от пакета single, перенеся все из него в support и еще куда надо. Пакет screens
cтановится единственным, и его можно поднять на уровень вверх - su.msk.dunno.scage

начать писать комментарии в формате javadoc

Мб объединить генерацию дисплейных списокв в UnicodeFont с генерацией в Renderer, для остальной части Scage
--
сложновато

еще раз продумать апи physics
--
Вообще, тут не надо думать, тут просто прогать надо, кучу разных проектов, где задействован физический движок. По мере
прояснения, что и где требуется и как применять, будет яснее и насчет ТЗ на апи.

доделать drawPolygon и drawFilledPolygon    (done)
--
не помню, что я там хотел доделать, но наверное доделал, пушо сейчас к этому апи претензий нет

Реализовать механизм ввода текстовой информации
--
окошко свинговое с текстовым полем

Переделать Tracer, чтобы сам вычислял где какой трейс лежит (хранил мап) (done)

Мб завести иерархию файлов строк, которые читает движок при запуске, или просто на этапе сборки мавеном начитывать в один
файл из умолчальных файлов и из application-specific.

Поправить взаимодействие Renderer со ScageScreen в случае, когда мы - main_screen (done)

Переделать цветные строки

Апдейт пропертей: возможность задавать цвета, а также векторные величины (из двух значений)
--
возможность задавать цвета сейчас реализована следующим образом: в ScageColors впилен метод, принимающий имя цвета
и отдающий цвет (задействована такая-то крутая рефлексия)

Мб все-таки хранить файлы resources внутри джарника программы, как все крутые пацаны делают (done)
--
аналогично мб проперти (done)
--
это адово необходимо, когда у нас webstart например

Надо разработать план по описанию движка Scage: словесное описание, примеры кода, готовые приложения разные, куча
картинок. Подробное описание способов быстрого создания нового проекта (через мавеновский архетип), сборки готового
приложения. Все это на русском, потом на английский перевести (как можно быстрее).

Добавить поддержку мышки в Controller (done)

возможность определять проперти через другие проперти
name = $app_name - $version

Надо продумать возможность перезапуска игры связкой exit - init, или просто init, чтобы можно было все грамотно
инициализировать - в частности, для физического движка чтобы все работало  (done)
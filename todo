СОВЕТИКИ
Нужно начать писать советики по разработке приложений под scage. Типа Best Practices. Постараюсь постепенно пополнять
список новыми советиками

* все action'ы, render'ы итд только в объектах, но не в классах.
--
Мм, спорно же... Ну, то есть, если внутри класса определены action'ы или еще что, значит там полюбас импортирован
соответствующий ScageScreen объект (ну или еще каким извращенным способом присутствует). Таким образом, этот класс
 все равно не удастся использовать в отрыве от объекта, как-то по-левому.. Или потенциальный баг в самом объекте, что
 он не сможет проследить за своевременным удалением action'а и такое сложно отследить... Ну хз.

* все var с модификаторами только private
--
Не актуально, за нас уже подумали. ОКАЗЫВАЕТСЯ, поля в классах всегда имеют самый зверский модификатор private[this], и если
мы выставили для var публичный или протектед модификатор, автоматически генерятся геттер и сеттер. Это оче круто,
на самом деле. Примечательно, что во всем коде scage мне понадобилось всего в двух местах удалить лишние геттеры-сеттеры)

* в трейтах стараться не писать конструкторский код, только def'ы и val'ы

* точка входа в приложение должна наследоваться от ScageScreen (или MultiControlledScreen) с параметром
is_main_unit=true

-----------------

Можно таки завести кнопку:
def windowButton(message: => String, coord:Vec, onClick:(m:Vec => Any), screen:Screen with MultiController):(Int, Int) {
    val i = screen.interface {
        print(message, coord, align = "center")
    }
    def area = {
        val Vec(w, h) = messageBounds(message)
        List(coord + Vec(-w/2, h/2), coord + Vec(w/2, h/2), coord + Vec(w/2, -h/2), coord + Vec(-w/2, -h/2))
    }
    val m = screen.leftMouseOnArea(area, onClick)
    (i, m)
}
функция возвращает два числа - айдишники операций, по которым кнопку можно удалить. Также можно сделать классом и в нем
сделать метод для самоудаления и все такое. Хз, где разместить этот метод, или класс и вопрос целесообразности.

задание messagesBase, interfacesBase в ScageXML

areaForMessage(), areForMessageCentered()

еще варианты *MouseOnRect*, где width, height - одним объектом Vec. Тогда туда сразу можно подставить значение messageBounds()

мб оптимизировать все эти *OnRect*, *OnRectCentered*, добавить функцию coordOnRect() - такая функция гораздо проще, чем coordOnArea(),
сделать прямые вызовы mouseButton() итд

добавить leftMouseOnRectCentered итд  (done)

адаптировать все последние фишки для commandLineInterface

надо поправить: функции msecsFrom* не учитываю паузу. Надо доработать апи, чтобы типа были и учитывающие и не   (done)
учитывающие паузу.

мб в ScageLib заебенить объявления типа:
type ScageScreenApp = net.scage.ScageScreenApp
итд, типа чтобы реально тока один импорт был и все. Может сработает?

Сделать ScageLib чисто объектом. В качестве трейта не используется никогда все равно.

Мб Events фреймворк вынести в виде объекта или трейта и унаследовать в ScageLib. Чтобы типа это была глобальная штука,
а не только в потрохах скрина. Иначе мб будет путаница если в проге несколько скринов, чей эвентс фреймворк задействован
в данном конкретном месте.
--
не унаследовать, а продублировать методы, чтобы можно было юзать отдельно объект Events, и из ScageLib

надо куда-то деть из контроллера функцию areLinesIntersect(), потому что это реально полезная функция, и она пригодится
не только там. Варианты: в Vec и DVec. Либо вообще создать новый класс Line... Правда, тогда что ли получается, надо делать
Line и DLine?.. Короче мб пока нах, и засунуть в объекты Vec/DVec.
--
Подумать, куда засунуть метод areLinesIntersect(), потому что это вообще полезный метод, и он нужен не только в контроллерах,     (done)
а например, клиентским приложениям тоже пригодится. Варианты: в объекты Vec/DVec, либо завести новый класс Line, и типа в него.
Правда, похоже, придется заводить Line/DLine... Вообще, надо бы разобраться с этими двумя классами для двумерного вектора
с разной точностью, а то какая-то порнография уже получается...
Другой вариант: в ScageLib. Также я почитал сейчас еще раз про package objects в Scala, и вот мб хорошая идея превратить
ScageLib в package object net.scage.
--
засунул в ScageLib. ScageLib оставлен объектом, в качестве package object он не нужен - это ничего не упрощает.

надо разобраться с параметрами для трейсера. Предусмотреть разные варианты задания параметров:
размеры игрового поля плюс количество клеток, либо размеры плюс h_x, h_y.

придумать доработку или воркэраунд к трейсеру или к чему-нибудь, чтобы уметь рисовать непрерывную картинку на границах областей при увеличении - чтобы не было "телепортаций"
при пересечении края экрана
--
в своем простейшем виде доработка заключается в отрисовке еще восьми копий основного кадра со смещениями на один
экран вверх, вниз, в стороны и по диагоналям. Фпс при этом падает в среднем в два раза.

phys2d, который используется в качестве физ.движка в scage, не развивается с 2008 года. В целом, он ничего, но есть
небольшие проблемы, например, такой комент в методе step() класса World:
Currently anything other than 1/60f as a step leads to unpredictable results - hence the default step
fixes us to this step
из-за чего в своей обертке ScagePhysics я пилю вот такой космический костыль:
def step() {
    _physicals.foreach(_.clearTouches())
    for(i <- 1 to _dt) {
      world.step()
      for(p <- _physicals) {
        p.updateCollisions(world.getContacts(p.body))
      }
    }
}
потому что дефолтного шага в 1/60 сильно не хватает (5/60 выглядит норм).
В общем, есть альтернативы среди физ.движков:
* JBox2D http://jbox2d.org/, http://code.google.com/p/jbox2d, в активной разработке, последние коммиты за 30 января 2012 (на текущий момент,
8 февраля). Доступен через мавен в репозитории sonatype (https://oss.sonatype.org/index.html#nexus-search;quick~jbox2d)
* JBullet http://jbullet.advel.cz/, java-порт сишного движка Bullet. В плане исходников и активности разработки менее вразумительный,
в частности, оно, кажется, не умеет в мавен. И не 2д к тому же

возможное перманентное накопление  сообщений в акторах сетевой подсистемы. Подумать об этом
--
в акторах сетевой подсистемы надо запилить событие status или state - чтобы по нему отдавал всякую инфу о себе, в том числе количество сообщений в майлбоксе.

подумать над множественными начитками restitution в физическом движке

Нужно продумать стандартный механизм идентификации клиентов. А то сейчас можно хоть телнетом подключиться, и сервак думает что это клиент
и создает под него игровые сущности и шлет ему инфу. В перспективе мб даже завести некую секурность - идентификацию на основе каких-нить
криптоалгоритмов, чтобы ботов сложнее было написать.

говорят, tcp/ip это не круто, круто - udp. По крайней мере для динамичных игр с
интенсивным сетевым обменом. Надо как-то продумать это и запилить использование
udp наряду с tcp/ip (под настройку например).

Запущенный дочерний скрин может попортить ряд графических параметров, и при возврате из него, неплохо бы их автоматически
восстанавливать. Это очень легко сделать, надо запилить метод runScreen() внутри какого-нить скринового трейта, и в нем уже
вызывать метод run(), перед ним сохраняя парамы, и после возврата из него восстанавливая их. Нужно только определить этот
набор восстанавливаемых параметров. На первый взгляд: backgroundColor, currentColor
--
еще при смене разрешения все сбрасывается

Набор методов в Vec, меняющие его внутренние поля - подумать о целесообразности. Многое бы упростилось и мб ускорилось,
но и возможностей для багов больше.
--
как обычно, годное решение - завести новый класс: mutableVec
--
сделать обертки toMutable / toImmutable и все такое) Вообще, годная вещь, можно будет обойтись без пересоздания координат
трейсов в трейсере например.
--
класс MVec - наследуется от Vec и имеет дополнительные методы +=, итд и прямые методы переопределения полей. И обновить
трейсер, чтобы использовал этот класс. Подводные камни: нужно переделать всю структуру Vec, добавить уровней абстракции,
потому что типа нельзя тупо отнаследоваться от Vec: у него внутренние поля x,y - иммутабельные.

мб внедрить сортед буфер для операций из scage

проперти: еще из аргументов, которые можно в программу передать (done)
--
реализован трейт commandLineInterface

мб логировать с уровнем info начитку пропертей, просто чтобы знать какие проперти начитываются

Впилить класс Vec с числами Double, чтобы конская точность была. (done)
--
надо бы как-то так изящно придумать, чтобы вся архитектура была сразу совместима с и со старым и с новым классом, и
очень просто было выбирать какой юзать.
--
без всякого изящества запилил конвертацию из Vec в DVec и наоборот и сделал имплициты в ScageLib
--
два класса Vec, DVec, в которых полностью повторены все методы, только тип разный - это плохо.

Мб обновить методы рисования в соответствии с примером Reflections в проекте blases.tests:    (done)
    ellipse.toList.sliding(2).foreach {
      case List(a, b) => drawLine(a, b, WHITE)
    }
а то обычный drawLines как-то хреновато отрабатывает, равно как и drawPolygon. Либо добавить еще такие методы в
дополнение к имеющимся.

Был эпический факап, когда попытался написать сетевую версию Space War: код, написанный на работке не заработал дома,
потому что параллельные потоки, race conditions, конкаренси и всякая такая хуйня. Для преодоления этого был запилен трейт
SynchronizedScage, но мб это не лучший вариант решения. Код сервера наверное не следует менять, пусть он так и остается
весь акторный и асинхронный. А вот клиентский код мб можно написать еще вариант - когда запрос данных с сервера осуществляется
в фиксированные моменты и является частью главного цикла, а не вынесено в отдельный актор.
---
Ну или иметь внутреннюю дисциплину писать потокобезопасно, обмениваясь с сетевым клиентом сообщениями из основного треда... Это,
впрочем, сложновато, потому что с общей однопоточной архитектурой движка согласуется мало... Хотя в акторс фреймворк
есть же возможность тупо чекать майлбокс, когда это удобно, так что какие проблемы. Надо бы как-нить сподобиться
написать пример.
--
надо отказаться от синхронизированных классов и всего этого. вариант взаимодействия с сетевым апи надо придумать ДРУГОЙ.
--
Короче, похоже все довольно просто:
action(10) {
  self.receiveWithin(10) {
    // ...
  }
  // ...
}
И в коде сервера посылаем сообщения основному треду:
val scage_actor = self
NetServer.startServer(
  onClientAccepted = (client) => {
    scage_actor ! (("new client", client.id))
  }
)
В общем, ЭТО РАБОТАЕТ, так что реально надо выпиливать всю синхронайзд-парашу из кода!    (done)
--
увы, начиная с 2.10 scala actors объявлены deprecated и предлагается перекатываться на akka, и там не оч пока понятно,
будет ли работать это замечательно решение с посыланием сообщений основному треду. На первый взгляд синтаксис стал
запутанней и вообще параша какая-то эта akka.

функциональность контроллеров может стать депрекейтед. Потому что есть мысли, как все делать через keyPressed/mousePressed внутри
экшенов и типа это более stateless.
--
хрен-то там: гораздо меньше контроля, например, много писанины чтобы контролировать время нажатия на клавишу, гарантировать,
что при нажатии на кнопку функция отработает только один раз итд. Короче, это только в дополнение
--
Новый вариант взаимодействия с контролами:
interface {
  control(KEY_A) match {
    case PRESSED   => print("I'm pressed", windowCenter, RED)
    case UNPRESSED => print("I'm not pressed", windowCenter, GREEN)
  }
}
---
Запилить таки нормальную реализацию экранных кнопок. Впилить это в функционал контроллера. Добавляем список вершин,
ограничивающих некоторый замкнутый многоугольник. При клике проверяем не попадает ли мышка в область какого-либо из
добавленных многоугольников. Если попадает - выполняем связанное с ним действие. Сигнатура функции:
def windowButton(area:Seq[Vec], on)
---
Доработка контроллера: получать информацию о состоянии контрола по его айдишнику. Требуется по сути сейчас для экранных
кнопок, но мб и для других контролов пригодится. Состояние такое: (was_pressed:Boolean, last_pressed_time:Long)
---
сделано:
добавлены методы: keyPressed, leftMousePressed, rightMousePressed, mouseOnArea. Этого в целом хватает, чтобы заебенить
оконный интерфейс и все такое
--
но все-таки методы, возвращающие инфу: (нажато/не нажато, сколько времени нажато, последний момент нажатия) - нужны..

Доработка сетевого апи: вариант шифрования, вариант сжатия, вариант идентификации клиентов/сервера. Попробовать еще раз
реализовать сетевые переменные.
--
кстати, внезапно осознал что эта концепция "сетевых переменных" это ж по сути велосипедная реализация какой-нить базы данных.
Во всяком случае все ТЗ можно организовать например в виде внешнего инстанса mongodb и драйвера доступа к нему из сервера
и из клиентов. Типа обновляют одну и ту же общую коллекцию, да и все. Так что нафиг это все.

----------------- версия 0.9.2 -----------------

Ниже версия 0.9.1:

Надо бы зафиксировать версию, и в следующей версии разработать таки удобную систему построения сетевых
приложений. Проект "сетевые переменные" немножко провалился, но можно его попробовать доработать и таки дожать.

мб перейти к использованию либы lift-json: в сетевом апи или вообще везде вместо State

еще функции центрирования:          (done)
* центрировать только по оси x
* left align
* right align

net api: реализовать функцию ask(question:State):State - типа мы посылаем "вопрос" серверу или клиенту, и блочимся,
пока не придет ответ.  (done)

впиливаю много всяких изменений, которые неизвестным образом сказываются на производительности. Наоборот, есть также идеи
допилить какие-то оптимизации, но неизвестно, нужны ли они, и скажется ли это как-то на производительности.
Короче, я остро нуждаюсь в бенчмарке, остро!!!

фреймворк tracers тоже надо сделать синхронизированным
--
нахуй, всю синхронизированность убираю наоборот.

Вариант контрола: работает только в режиме паузы (сейчас есть: работает только если не на паузе, работает всегда) (done)
--
тут кстати может быть подводный камень с onKeyUp если в onKeyDown сменился on_pause.   (done)
Впрочем, в клавишах смены вроде onKeyUp не юзается, да я его и вообще почти нигде не юзаю...
--
NoPause -> IgnorePause, Pause -> OnPause. Итого три возможности:
без суффикса: работать, если не на паузе
IgnorePause: работать в любом случае
OnPause: работать, если на паузе

что необходимо доделать:
* поддержка апплетов (done: решение мб не сверхэлегантное но по кр мере работает)
* работа из нескольких потоков

* с архетипом проблемы: системные либы lwjgl присутствуют внутри jar-файлов

* использовать мавеновские плагины shade и proguard - для получения одного джарника вместо кучи и уменьшения его
размера за счет выпиливания неиспользуемых классов.
--
proguard плохо шринкает, так что потом джарник не запускается, shade работает ок, но похоже системные либы lwjgl
впихнуть внуть общего джарника не получится. JarSplice умеет такое, но он не работает с мавеном, а имеет гуевый
интерфейс.

* приделать профиль -Papplet со сборкой апплета
--
для апплета пригодился бы один джарник на все. Так удобнее. Для jnlp в целом тоже, да и вообще

* андроид
* 3D

net api: sendToAllExcept, sendToAllExceptSync    (done)

надо бы вернуть возможность менять framerate (done)

сделать ScageProperties уметь воспринимать проперти, переданные в командной строке по -D (done)

delOperationIfExists, delOperationsIfExist, delOperationsIfExistExcept (done)
--
NoWarn вместо IfExists

дополнительные таймеры: с момента старта приложения, с момента старта экрана, с момента последнего рестарта... (done)

Еще надо подумать про паузу и периодические экшены: после того как сняли с паузы, если держали достаточно долго, у всех
периодических экшенов сразу сработает условие и они все выполнятся. Мб на период паузы обновлять им last_action_time
--
фигня

нужно разработать механизм, чтобы периодические экшены вообще не вызывались, если сейчас они гарантированно не выстрелят.
Например можно хранить экшены как мап: время срабатывания -> список функций. Причем пусть это будет TreeMap!
И тогда мы по msecsFrom сразу получаем список ключей, экшоны на которых надо выполнить.

ColoredString - попробовать сделать принимать Any, геттеры (text, originalText, colorSwitches) записывать без скобок

передавать в drawRect* в качестве ширины и высоты вектор (одно значение вместо двух)
trace.state("pewpew", 15) вместо trace.state.valueOrDefault("pewpew", 15)

операции: clearOnce, initOnce, actionOnce, delayedAction
--
забил пока

Подумать над ускорением удалялок операций - если контейнеры функций переделать из аррайбаферов в хешмапы, как для events,
то удалять по id станет быстрее. Еще SortedBuffer можно сделать на основе Vector - быстрее будет вставка.
--
Vector - иммутабельная структура. Хешмапы к ускорению тоже не оч помогают.

Версионирование. Непонятно, что делать с версиями дальше. Переваливать через 1.0 неохота, и упираться в него,
повышая минорные версии, в общем-то, тоже. Плюс, непонятно, когда наступает момент повышения версии: ориентироваться на
периоды разработки или на количество новых добавленных фич? Мб перейти на другую систему присваивания версий. Как вариант:
месяц-год. 052012, 062012 итд. Повышать, соответственно, раз в месяц. Хотя лучше все-таки как-то учитывать и количество фич,
чтобы версии по наполненности были более-менее равномерные...

пути дальнейшего развития:
* порт для андроида
* 3D (поботвить подробнее opengl)

нужны методы printCentered, по аналогии с drawRectCentered итд. Нужно вычислять прямоугольник, в который вписана строка,
которую хотим нарисовать и при ее рисовании соответствующим образом смещать точку ее рисования так чтобы переданная в
аргументах координата размещалась по центру строки.

это уже пахнет задротством, но мб предусмотреть еще одну стадию жизненного цикла экрана:
заход в экран в САМЫЙ ПЕРВЫЙ раз. типа prepreinit. Выполняется за все время работы приложения вообще один единственный раз,
в дальнейшем если и есть перезапуски экрана, то выполняется preinit, а эта стадия пропускается. Аналогично в конце: postdispose,
выполняется при самом-самом последнем выходе из экрана, то есть когда stopApp() вызвано. Подумать о возможных юзкейсах для этого.

прочитал что в андроиде похожая идея с экранами, есть жизненные циклы экранов, которые выполняются когда
экран останавливается/запускается. Только там вроде как не втупую вызов следующего экрана где-то в коде
логики предыдущего и соответственно возврат в точку вызова при его остановке, а нечто более интеллектуальное,
наподобие использования гипервизора: стек экранов и все такое. Надо подумать, можно ли у меня запилить такой
стек, и имеет ли это смысл? На первый взгляд не очень-то имеет, потому что бывает не нужна полная остановка текущего треда,
либо придется усложнять логику чтобы при его восстановлении все там какие-нить данные восстанавливались.


Я вроде наконец сообразил для чего мог бы пригодиться events-framework. В общем, бывает такое, что переменная заведена
где-нибудь, но менять ее позарез требуется из разных классов, так что полностью приватной ее не сделаешь. Можно конечно,
сделать из нее проперти, но если в ее сеттере будет просто присваивание переменной нового значения, то с тем же успехом
снимаешь модификатор private и не ебешь мозг. Но тогда этот сеттер может теоретически вызываться кем угодно, и проблема
мутабельных изменяемых состояний предстает во всей красе (конечно, если все же завести сеттер, то можно в нем поставить
брейкпоинт и отследить, какой пидор нам портит переменную, но если обращений к ней много, это может быть сложно).

И тут-то на помощь нам и приходит events framework! Там где мы объявили переменную, мы также задаем, в ответ на какие
события и что именно с ней следует сделать. Синтаксис нужно предусмотреть как в акторах, чтобы можно было передавать
произвольный набор дополнительных параметров. Ну и потом все заинтересованные лица просто вызывают нужный эвент, и все,
что нужно, на этот эвент реагирует. Переменную при этом с чистой совестью можно заводить private и делать ей один геттер.

Например, в игре Blases когда шипы лопают пузырь, они уменьшают счет за уровень на 100 очков. Вместо этого можно дергать
event типа "Пузырь лопнул" и по этому эвенту будут нужные изменения со счетом происходить уже в основном классе.

Впрочем, меня немного пугает производительность этого всего и опять же нужность...


расставить sealed где-нибудь, говорят это помогает от оптимизации
посмотреть, где можно заменить сигнатуры def foo(a:Any) на более кошерные def foo[A](a:A)
посмотреть, где можно заменить наборы параметров, по умолчанию начитывающиеся из пропертей, на имплицитные параметры

подумать над оптимизацией передачи параметров трейсерам: мб передавать только h_x, h_y...

IntersectablePolygon из проекта Blases содержит отличные наработки для эпичного апгрейда фреймворка tracers: по аналогии можно сделать
трейсы иметь форму и определять пересечения! Сейчас трейсы по сути - просто точки. В клиентском приложении можно определять для
них какой-нибудь размер, то есть считать их кругами. По умолчанию это все надо ставить, но еще добавить возможность
задавать им вершины и считать их полноценными полигонами. location будет центральной точкой, вершины будут окружать ее
--
Есть конечно же некоторые проблемы. Изначальная парадигма разбивать все поле на прямоугольную сетку. Весь фреймворк tracers
ориентирован на то, что объекты будут размерами примерно как ячейки сетки

StaticPolygon надо бы научиться двигать

мб донести в ScageLib всякие фабрики классов, чтобы и их импортить не надо было.   (done)

надо бы переделать апи по удалению событий от клавиатуры/мыши. В текущем виде оно не очень юзабельно: во первых, я его    (done)
никогда вроде и не юзал, во вторых, оно и первоначально годилось только для SingleController, а теперь, когда допилен
MultiController и активно используется, оно неюзабельно тем более. Но похоже наворачивать там придется столько, что с
наскока я это не осилю. Что мне хочется:
как в Scage, одну функцию delKeys... мм, я только что мысленно кончил =)
в общем, это даже можно оформить в качестве delOperations, чтобы она принимала и распознавала типы операций - события
от клавиатуры и мыши, как сделано для Рендерера. Проблема заключается в том, что контейнеры событий имеют очень разнотипную структуру, и многие
из них и так уже хашмапы. То есть придется что-то типа наворачивать хашмап над хашмапами, и мне как-то страшно...

мб сделать везде единообразно и где "scage.properties" - переписать на "scageproperties" (пушо наоборот из-за особенностей   (done)
вебстарта сделать не выйдет).
--
сделал понимать все варианты

Вощем, нужно придумать стандартный механизм уметь программно показывать версию приложения из pom.xml. Похоже, самый простой путь для этого -  (done)
завести в ресурсах новый файл, например maven.properties с содержимым типа:
version = ${project.version}
и добавить этот файл в pom.xml в список ресурсов для фильтрации. Тогда на самом раннем этапе сборки, еще до компиляции в этот файл попадет версия,
и впоследствии этот файл окажется в джарнике, то есть будет доступен ровно также и в собранном приложении. Можно парсить этот файл, используя
стандартный явашный класс Properties.
Проблема здесь такая, что все эти замечательные действия нужно будет проделать над клиентским приложением и, например, внести maven.properties в архетип.
А апи соответственно, рамзместится в библиотеке (в ScageProperties). Если проект будет создан не из архетипа, апи работать не будет. Вощем, как-то неконсистентно.
--
сделал, переебашив ScageProperties. Теперь оно умеет принимать произвольное количество файлов с пропертями
(задаются через запятую: -Dscage.properties=prop1.properties,prop2.properties,...) и искать последовательно в них всех. Принудительно подсовывается файл maven.properties
и в этом файле ключам присваиваются значения свойств из pom.xml. Файл maven.properties фильтруется на этапе генерации ресурсов, и так туда все нужное попадает.
Бедненько но стильненько.

сделать ScageXML уметь менять локаль на ходу и переначитывать мессаджи. Это очень крутая фича, типа переключалка языков   (done)
будет по кнопке

Похоже, все функции в RendererInintializer теперь достаточно универсальны и опираются только на приходящие аргументы,   (done)
и на функции из RendererLib, то есть RendererInintializer вообще не нужен больше как отдельный трейт, и все функции
из него можно перенести в RendererLib. Подумать об этом.
--
профит от этого такой, что можно будет импортить только net.scage.ScageLib и менять разрешение и всякое такое, без
дополнительного импорта основного класса приложения (потомка ScageScreenApp)
--
удолил. Испытываю сплошое удовольствие теперь)

ВНИМАНИЕ: UnicodeFont козлит, если в качестве координат на отрисовку сообщений отдавать нецелые числа. Следует иметь
в виду этот невъебенски важный факт!

вроде прикольно получилось в Blases запилить Button. Мб завести новый пакет ui (в пакете support), где сложить всякие
стандартные элементы интерфейса. Только тогда нужно еще продумать возможность их кастомизации, и сделать какие-нибудь еще
элементы, а то пока один Button и есть. Можно в принципе оставить их реализацию клиентским разработчикам, просто сделав
руководство по их созданию (на примере того же Blases).

подумать про вызов restart() из одного из экшенов. Типа мб лучше сделать чтобы restart() вызывался после всех экшенов    (done)
--
кажется не должно быть проблем. Экшены спроектированы так, что не сохраняют и не гарантируют порядок исполнения, то есть
подразумевается, что порядок исполнения не важен. То есть, если в одном из экшенов произошел вызов restart() и исполнение
продолжилось следующим экшеном, как бы с середины - должно быть пох... Типа, нет разницы, с середины или с начала. Наверное.
--
все так, единственные подводные камни: сообщения в логе типа такой-то трейс или такой-то физикал или такая-то операция нот фаунд.
Типа довыполняется остаток экшенов, а все объекты, которые там крутятся уже удалены, и сами эти экшены на самом деле мб тоже удалены.
Но это все ограничивается ворнингами в логе только если используется стандартное апи. Если какие-то хаки, можно и nullpointer словить.
--
переделал с использованием приватной переменной restart_toggled. Теперь, если в одном из экшенов произошел рестарт, все следующие
не выполняются.

сделать для ScageScreen тоже возможность задавать тайтл в качестве параметра....
--
мб использовать в качестве title - unit_name от ScageScreenApp с возможностью менять его при переходе на другой скрин

мб завести что-то типа onPhysicsCoordChanged() - чтобы не приходилось в трейсере обновлять координату физического объекта на каждом шаге
--
смысла особого нет, потому что координату физический движок все равно и так меняет на каждом шаге обычно.

запилить функции в NetServer: sendToAllExcept(), sendToAllExceptSync()   (done)

продумать механизм опертиавного дисконнекта отвалившихся клиентов. очевидный путь: уменьшить пинг_таймаут, но тогда без   (done)
конца будут мусорные пинги, которые ни к чему в тех типах сетевых приложений, которые и сами постоянно что-то шлют.
Мб нужно какое-нибудь апи, чтобы клиентские приложения сами могли офлайнов отслеживать и давать команду на очистку в нужное время.
--
еще можно таймаут очистки от офлайнов запилить под отдельную настройку (net.offline_check_timeout) и уменьшать только ее, а пинг. например, вообще
отключить. еще можно поиметь некий стандартный механизм общения клиента и сервера в начале и в конце. Сейчас сервер вначале присылает accepted, а
в конце disconnect, а клиент у нас весь такой молчаливый. Это и к вопросу об идентификации клиента.

пишут
http://stackoverflow.com/questions/5740906/how-to-check-for-null-in-a-single-statement-in-scala
что это scala-way избавляться везде от null и заменять на Option. Надо просмотреть код scage на предмет такого (например,
net api)

запилить функцию drawTraceLocations() (done!)

перепилить Trace:                           (done!)
trait Trace -> trait TraceTrait
добавить отдельный класс Trace, где changerType = Trace

лоигрование загрузки картинок по аналогии со шрифтами итд

фиксируем версию 0.8 и съебываем на гитхаб! (поросенок Петр, почти (с))

похоже, идея с сортировкой функций рисования при всей своей винрарности не очень применима на практике и нуждается в доработке - потому что в реальных проектах
по сути, видимо будет требоваться всего одна функция отрисовки, выполняющаяся безусловно, и она уже в свою очередь будет решать, что нарисовать, а что нет - таким образом,
порядок рисования нужно будет вычислять другими средствами, предложенный механизм не годится. Есть несколько путей решения проблемы:
* впиливать динамически заполняемый мап allow_render
* разобраться с опенгльным depth-buffer. Я как-то уже пробовал, у меня не заработало, и я забил разбираться. Мб надо дожать это. На первый неискушенный взгляд это решение
 кажется лучше, потому что встроено в потроха opengl, типа ничего и делать не надо (а все есть).

переделать контроллер (^^) с использованием partialFunction:
controls {
  case "KEY_W" => (wanna_go_up = true; wanna_go_up = false)
}
пока просто подумать об этом, концепт типа

мб все проперти которые начитывает движок, поместить в lazy val в ScageProperties, и брать их оттуда.
--
по моему, не нужно

придумать как вписывать версию в джарник в манифест и как ее забирать оттуда. Чтобы не вписывать номер версии в 100500 местах (в pom.xml и в файле пропертей - для отображения в заголовке окна),
а только в одном (в pom.xml)
--
аналогично можно попробовать поступить с именем

попробовать вытащить из phys2d алгоритм такого-то крутого collision detection'а

уметь задавать window_width, window_height в коде (по умолчанию берутся из пропертей) (done, вынесены в качестве параметров в ScreenApp, по умолчанию по прежнему берутся из пропертей)

net api, рассмотреть юзкейсы:
* ввести с клавиатуры порт и стартовать на нем сервер. Остановить сервер по событию с клавиатуры, потом начать снова на новом (заданном) порту (done, теперь вроде должно уметь так)
* ввести с клавиатуры брл и порт для подключения и стартовать клиент. По событию с клавиатуры отключиться, затем подключиться к новому хосту. (done)

Все-таки попробовать уменьшить количество импортов (done! впилил таки ScageLib, уряяя!!!))

сделать NetServer уметь сообщать что он закончил работу для корректного выхода (чтобы можно было подождать, пока все
треды завершатся). (done, сделал дополнительные методы sendSync() - синхронные посылалки, а также сделал метод disconnect() тоже синхронным,
то есть основном поток будет ждать сигнала его завершения и только после этого продолжать).  (done)

сделать Renderer, который object и Renderer, который trait - одной структурой, сделать в ней метод initgl с модификатором
private[scage], запускать его из main в ScageScreenApp... (хм, короче я разобрался с этим, done)

или все-все трейтами переделать... Ладно, если только понадобится.

Несколько статей про сетевой фреймворк Netty и технологию NIO, на которой он основан
http://habrahabr.ru/blogs/java/136456/
http://habrahabr.ru/blogs/gdev/136765/
критикуется архитектура сервера, когда на каждое подключение создается по потоку (а я еще и по два хотел, на ввод и вывод) -
поскольку переключение между потоками в яве удовольствие дорогое, нужно стараться обходиться как можно меньшим их количеством.
В общем, мб сетевое апи надо на этом Netty переписать
--
допилил через акторы, должно быть годно, стопицот тредов не создается, так что нахуй нетти пока что.

Доработка интерфейсов: контролы. Тег <control>. Область в виде многоугольника (задается координатами).
При клике на него генерится событие, и по этому событию можно что-нибудь сделать. Пока концепция.

В net api может быть надо еще делать по потоку (актор) на отправку сообщений. То есть на сервере на каждого клиента два
потока: на прием и на отправку, и на клиенте два аналогичных потоков. А то отправка немного тормозит.
Еще надо сделать сервер и клиент не быть синглтонами. В принципе все легко, можно сделать аналогично трейсерам. Параметров реально мало,
четыре штуки всего, проблем никаких не вижу. Разве что отдельно запилить возможность динамически выбирать незанятый порт -
вот это будет чуть посложнее. Но это можно на потом оставить.
--
В идеале, конечно, лучше бы доделать совсем ынтерпрайзно: когда отправляем/принимаем очередное сообщение, забираем из пула
новый тред, и он продолжает слушать. Когда тред закончил отправлять/принимать - возвращаем в пул. Количество тредов в пуле можно задавать настройкой.
Будет такой крутой доморощенный томкат =)
--
эта ынтерпрайзность впилена в Scala, "акторы" называется =) Переделал под них сетевое апи.

Перепилить все подсистемы, чтобы наряду с начиткой из ScageProperties умели принимать настройки напрямую в виде параметров.
Чтобы типа альтернатива была. Это в частности касается Renderer, ScagePhysics и net api. (хм, вроде везде done)

ScageProperties: придумать что-нибудь, чтобы источником пропертей был не только файл, а что угодно (например, принимать проперти по сети).
Это пока типа концепции.

проперти: парсить Vec, ScageColor и State. Уметь в формулы плюс запоминание констант (последнее касается также ScageXML). (done)

State не умеет в Int, парсит из json во float, с этим можно что-то сделать, по идее. Алсо надо бы перепилить формат, чтобы умел:
{blabla:"pewpew"}, наряду с {"blabla":"pewpew"} (типа строковый ключ в json необязательно заключать в кавычки)
--
ключ в формате json всегд надо в кавычки брать. Насчет парсинга в int пока забил - а что если очередное значение оказалось целым,
а на другом конце ждем float? Типа не угадаешь, так что пусть будет что-то одно (float)

доработка ScageId:
сделать объектом (забить на класс), в нем два метода:
def nextDisplayListId:Int
def nextId:Long
проблема с дисплей_листами, что opengl принимает для них int и не желает long, но остальным участкам кода лучше бы long,
он гораздо больше чисел содержит, а переполнение количества операций свыше двух миллиардов вполне возможно. Хотя в довершение
надо бы сообразить корректную ротацию айдишников при переполнении или хотя бы эффективный fast-fail - чтобы приложение
сразу обсиралось при превышении. А так это все все равно ненадежно.
--
эта проблема остро не стоит, ну и хрен с ней

мб написать свою парсилку пропертей, чтобы она парсила их в объект State
--
да, но зачем? (с)

Снова появилась идея завести один глобальный импорт, чтобы не импортить каждый раз кучу всего. Если коротко, и без
деталей реализации, это может быть объект ScageApp, от которого надо унаследовать трейты:
import net.scage.handlers.Renderer._
import net.scage.support.ScageColors._
import org.lwjgl.input.Keyboard._
import net.scage.support.messages.ScageMessage._
import net.scage.support.messages.ScageXML._
import net.scage.support.ScageProperties._
ScageId._
Но трейты надо сначала аккуратно написать... В общем, есть о чем подумать           (done! ScageLib!)

Включить в Scage:
http://code.google.com/p/http-bot/source/browse/trunk/src/su/msk/dunno/httpbot/support/Conn.java
http://code.google.com/p/http-bot/source/browse/trunk/src/su/msk/dunno/httpbot/support/parsers/HtmlParser.java
http://code.google.com/p/http-bot/source/browse/trunk/src/su/msk/dunno/httpbot/support/parsers/FormParser.java
для взаимодействия с http. Парсеры, конечно, лучше накарябать свои, но встроенный в Scala xml-фреймворк,
к сожалению, скорее всего не подойдет для html(

сжатие сетевого трафика. В перспективе - шифрование (опциональное, ессно). Причем, сжатие придется писать самостоятельно, потому что
встроенный в жабу gzip немножко не так работает как нам нужно (требует закрывать канал)
--
Есть такая гугловая либа snappy: http://code.google.com/p/snappy-java/, думаю заюзать ее, но пока не до конца разобрался:
http://groups.google.com/group/xerial/browse_thread/thread/8bc9d36c810eda72?hl=en

ШкагеПропертиш НЕОБХОДИМО сделать трейтом!!
--
идея все-таки фейл, потому что бессмысленно это. Ну да, ScageApp теперь носитель настроек, и клиентский код может брать настройки у главного
окна приложения. Круто. Но неклиентский а библиотечный мой код срать же хотел на ScageApp, ведь это класс, а не объект. А настройки моему
библиотечному коду точно также нужны. Так что искать он их будет продолжать в объекте ScageProperties, и никуда от этого не деться.
Ментальный онанизм последней пары дней привел меня к тому что теперь есть один объект ScageProperties, который начитывает имя файла с
настройками из системной проперти -Dscage.properties. Если она отсутствует, используется имя scage.properties. В таком варианте мы полностью
гарантируем наличие уникальность и иммутабельность объекта с настройками для приложения: нет никаких препятствий к его инициализации, и никто
его никогда не перезапишет.
Минусы: если в джарнике есть на самом деле несколько программ, и каждая использует свой файл с настройками, чтобы все правильно
запустить, теперь нужно в строке запуска указывать еще и -Dscage.properties, а раньше достаточно было просто другое имя запускающего
класса указать - имя нужной ему проперти было вписано в параметры конструктора. Может можно как-то научить либу понимать какой файл
какому классу нужен? Например, уметь начитывать имя класса, из которого взята текущая точка входа
и искать файл <имя_класса>.toLowerCase+".properties". Но зато теперь можно удобно подкладывать разные файлы настроек проге, просто меняя
строку запуска, без перекомпиляции. Хз, правда опять же, нужно ли это.

попробовать все же еще разок сделать main unit единственно возможным в системе, и чтобы с него начинался запуск приложения (в нем точка входа) и отложенно вызывался run(), чтобы
самостоятельно его вызывать не надо было (посмотреть, как это сделано в трейте App).

еще апдейт контроллера: вынести отслеживание событий по нажатию кнопок клавиатуры и мыши (was_pressed, last_pressed_time) в объект, чтобы эта инфа была независима от текущего
запущенного экрана и была общей для них всех. В текущей реализации, если, например, по нажатию на какую-либо кнопку осуществляется переход в новый экран, и в нем, в свою очередь по этой же
кнопке осуществляется выход - мы сразу выйдем обратно. Данная доработка должна поправить этот баг.

апдейт контроллера: события по нажатию нескольких клавиш (ctrl-Z, shift-C итд)

мб избавить от ScageMessage и все методы перетащить в Renderer? Хотя нах надо...
--
обратное предложение: сделать трейтом! мм, тоже фейл же...

мб вынести ScageColor в отдельный файл, и все три файла (ScageColor, ScageColors, ScageColorTest) отправить в отдельный пакет colors

Придумать стандартный способ останавливать приложения на основе Scage (без графического интерфейса). Я голосую за какой-нибудь веб-интерфейс или типа того.
--
а вот можно еще так:
val sc = new Scanner(System.in)
и на каждом шаге:
if(sc.hasNextLine) {
    val line = sc.nextLine().trim()
    line match {
        case "exit" | "quit" => Scage.stopApp()
        // more cases here...
        case _ =>
    }
}
правда, Scanner и всякие там hasNextLine() на первый взгляд не выглядят легкими и дешевыми, так что мб лучше эту технику оставлять опциональной на совести приложений, которым такое
действительно надо (например, графическим такое нах не надо, имхо).

добавить в ScageProperties парсилку арифеметики, дописывать ей в константы все вводимые ключи, чтобы их тоже можно было использовать.
реализовать ввод значений Vec и ScageColor

Переписать ColoredString через комбинатор парсеров (главным образом, чтобы поучиться его использовать).
--
Хотя наверное не получится: текущая реализация не context-free (если стоит слеш - не делать color switch) и отказываться от этой фичи не хочется

сетевая часть: перепилить с синглтонов на классы, чтобы была возможность стартовать в одном приложении несколько
серверов/клиентов. Реализовать companion objects - в них запилить текущий порт - увеличивать его на 1 при старте
очередного сервера/клиента, либо при эксепшоне

сетевая часть: запилить крутой парсер json (готовый, из стандартной библиотеки или сторонний, в крайнем случае самому
написать, прочитав главу Parcers из "Programming in Scala, 2nd edition"), чтобы был такой же удобный, как для xml.

сетевая часть: периодические сообщения keepAlive с заданным интервалом (меньше checkTimeout), чтобы не зависеть от
клиентского кода в плане посылки сообщений. Тогда можно поощрять checkTimeout (сделать ненулевым по умолчанию)

удаление клавиш

продумать:
* гарантии инициализации пропертей (проперти в виде трейта?)
* независимость рендера от пропертей (передача нужных вещей в виде параметров в функцию инициализации)
* независимость ScageMessage от пропертей
* логирование запуска юнитов
* трейты Renderer и ScageController получились неотделимы от Scage, отдельно их не получится использовать. Подумать, насколько
это плохо.
* реально ли делать рестарт приложения просто вызовом init (без exit) - тогда можно было бы избавиться от
дополнительного dispose. если же это нереально - запилить функцию restart:
def restart() {
  exit()
  init()
}

надо придумать и написать PerformanceTest

сделать профиль noscagelogo, и в нем собирать либу без логотипа Scage. По умолчанию собирать с логотипом. От
настройки scage.logo в Renderer избавиться.

всегда явно писать тип возвращаемого значения

проставить в нужных местах final и sealed

полностью делать интерфейс экранов в xml, как в андроиде. Продумать язык описания интерфейса.
--
пример xml:
<interfaces>
    <interface id="player.stats" x="20" y = "300" xinterval="5" yinterval="20">
        <row id="player.health" x="20" y="300">
            HP: $0
        </row>
        <row id="player.energy" x="20" y="300">
            Energy: $0
        </row>
        <row />
        <row id="player.defence">
            Def: $0
        </row>
        <row id="player.infection">
            Infection Level: $0
        </row>
    </interface>
</interfaces>
в строчках вместо message_id будут подставляться соответствующие строки из файлов со строками
Вызов из кода:
interface {
  ScageMessage.printStrings(ScageXML.xmlInterface("player.stats", 100, 50, 50, 0), 300, 400, 20)
}
100, 50, 50, 0 - значения, которые следует подставить в строчки вместо знаков вопроса. Здесь такой
момент, что строчки вообще говоря могут иметь произвольное количество знаков вопроса и надо скармливать каждой строке
из этого набора параметров только то, что имеет отношение к ней.
20 - межстрочное расстояние. xmlInterface() возвращает массив строк, они печатаются одна под другой функцией
printStrings(), которая принимает массив строк
--
мб передавать в тегах row также аттрибут message:
<row message_id="player.defence" message="Defence: ?" />
и использовать эту строку согласно какому-нибудь критерию (типа если по айдишнику найти не удалось/айдишника нет)
--
придумать как задавать в xml значения координат через функции от размеров окна (типа резиновый интерфейс) и относительно
положения других интерфейсов
--
в файлах строк мб тоже запилить поддержку аттрибутов координат и цвета
--
насчет задания в пропертях и xml всякого через функции от размеров окна итд - можно впилить самописные парсеры с помощью
встооенного в скакалку генератора парсеров (глава 33 "Programming in Scala, 2nd edition")

перепилить функции-удалялки через няшное collections api (done, перепилено вроде. Во всяком случае, все эти места уже основательно
переебашены и не один раз)

в трейсерах:
getState -> state (done)
traces_in_point -> traces_points (done)

point_matrix -> изменить тип: Array[ArrayBuffer[T]]
--
не годится, придется делать toList в методах, отдающих куски из point_matrix (прям ArrayBuffer-то стремновато отдавать)

http://www.scala-lang.org/node/10473
По ссылке скакалочные изменения в версии 2.9.1
Это надо внимательно прочитать и по возможности впилить в scage, куда надо.

Например, паралелльные коллекции. Это ведь круто?

The App Trait, The DelayedInit Trait - вот мне очень хочется избавиться от обязательного def main(args:Array[String]) {run()}
в объекте-главном экране. В идеале это должно быть что-то такое, что мы пишем весь инициализированный код в нашем
клиенстком объекте, а при запуске, будет вызван он и потом run(). И еще надо чтобы учитывалось, что наследник
ScageScreen может не обязательно быть объектом и тогда чтобы в нем не было ни main, ничего такого.

New methods in collections:
collectFirst, maxBy, minBy, span, inits, tails, permutations, combinations, subsets


можно запилить в init нечто вроде проверки: после отработки всех init-функций мы подсчитываем количество экшонов,
рендеров и интерфейсов. Если количество чего-нибудь увеличилось с последнего запуска инит, отдаем ворнинг с
информацией, чего стало больше. По идее, повторные вызовы init означают перезапуск приложения, то есть по идее все
 в нем должно вернуться к исходному состоянию. Если чего-то стало больше - где-то прога не удаляет за собой, и это
 может привести к переполнению, тормозам итд.

Я прочитал в книжке про ковариантность и контравариантность, и теперь можно подумать, надо ли запиливать что-то
такое в трейсерах

Круто! Оказывается, текущая архитектура контроллера не позволяет добавлять несколько событий на одну клавишу, например,
как-нибудь так:
  key(KEY_1, onKeyDown = println("1!"))
  key(KEY_1, onKeyDown = println("one!"))
отработает только последнее!
С кнопками мыши и другими ее событиями ситуация немного отличается, но работает тоже нестабильно.
---
мб пойти в обратную сторону и запилить возможность на каждую кнопку клавиатуры/мыши, на мышиные
движения/перетаскивания и колесико вешать ровно одну функцию. Повторное добавление перезаписывает текущую

Сделать, чтобы окошко по центру экрана запускалось (done, хотя возможны траблы на мультимониторной системе)

Одноразовые самоудаляющиеся экшоны. Экшоны запускающиеся с задержкой (типа синтаксический сахар такой. И то и то сейчас
может быть реализовано средствами движка).
--
пока неактуально

Сделать объект-компаньон-фабрику для ScagePhysics. Пусть будет апи, похожее на те, что предоставляют объекты коллекций:
val physics = ScagePhysics(ball, floor, left_wall, right_wall, roof, table)
типа оно нам сделает physics и сразу туда добавит нужное. Подумать аналогично про трейсеры.

Доработать апи в ScagePhysics в части касающейся регистрации касаний-столкновений. Вроде phys2d умеет определять точку
касания, надо ее отдавать. Важно же знать не просто, что тела коснулись, а каким они местом коснулись (например,
ударились об стенку в процессе падения, или таки уже ебнулись об пол и пора умирать).

physicals в ScagePhysics - сделать ArrayList
--
или ArrayBuffer, а чо

Renderer: мб scale тоже сделать функцией?.. Подумать о производительности функций center() и window_center()
window_center() особо не используется, кажется он использовался в Blamer только..
Мб предусмотреть два режима: когда эти штуки - изменяемые переменные, и когда функции...
--
этак и backgroundColor и color можно запилить функциями... В общем, серьезно подумать о целесообразности
--
гыгы, нее, низя scale сделать функцией. Иначе будет обсираться более простой юзкейс:
key(KEY_ADD, onKeyDown = {scale += 1})
типа по нажатию на плюсик увеличить масштаб. Если scale будет функцией, то эта функция:
{scale + 1}
будет вызываться каждый такт, в результате после нажатия на плюс картинка начнет непрерывно приближаться.
Воркэраунд от этого выглядит более херово:
private var my_scale = 1
scale = my_scale
key(KEY_ADD, onKeyDown = {my_scale += 1})
три строчки вместо одной. Аналогичные возможные траблы с color и backgroundColor. С другой стороны, с текущим апи,
если нам надо, чтобы масштаб изменялся в зависимости от чего-то, мы пилим что-то такое (пример из проекта Uke):
action {
  scale = if(Uke.coord.y - fartherst_coord.y > screen_height/2) screen_height/2/(Uke.coord.y - fartherst_coord.y) else 1
}
примерно такое же было бы написано, если scale - функция:
scale = {
  if(Uke.coord.y - fartherst_coord.y > screen_height/2) screen_height/2/(Uke.coord.y - fartherst_coord.y) else 1
}
как-то так, кароч

ScagePhysics: изменяемый dt (done)

GRAY и DARK_GRAY надо бы местами поменять (done)

подумать над усложнением схемы работы: предусмотреть возможность перезапуска. Изначально подразумевалось, что код в списке
exits будет вызываться только при окончании работы приложения. Но конечно же суперудобно сделать возможность перезапуска
игры без выхода из приложения, тем более что это достигается практически нахаляву связкой exit(); init();
Проблема в том, что в exits может содержаться код, освобождающий ресурсы насовсем, так что последующие init() и run() обосрутся.
Конечно, не до конца понятно, нужен ли такой код под ява-машиной, все равно, при выходе jvm освободит все...
Вощем как вариант можно запилить еще один список функций, только название для него пока не придумал

Вообще кастомиазция процесса старта приложения и его завершения - отдельная тема, но пока не актуальная. Пока:
слово Loading..., потом логотип движка, потом логотип игры, если есть или вступительная фраза (имя разработчика например),
дальше собственно игра. Показ логотипов и фраз все по 1 секунде, фразы пишутся слева сверху зеленым цветом главным шрифтом.
После игры - слово Exiting...

апгрейд парсилки xml:
пусть принимает еще произвольные аттрибуты, например цвет сообщения, позиция, пауза перед выводом итд. Пусть функция xml()
возвращает json со всеми этими данными и из него уже можно будет нужно вытаскивать

написать функция color:String -> ScageColor (done)

настройка id.start не нужна, потому что нет никакого смысла ее менять, и даже сейчас к этому есть препятствия:
она должна быть не меньше 10000. Пусть она просто будет 10000  (done)

drawRect и drawFilledRect принимают координату и считает ее центральной! Надо еще чтобы был левый верхний угол, как обычно. (done)
--
старые функции переименованы с добавлением префикса Centered. Обратную совместимость я в гробу видал, притом что проектов
все равно никаких нет пока :3

баг с отрисовкой физических полигонов закрашенными мнгоугольниками (функция drawFilledPolygon)

action'ы, которые не тормозятся паузой. Сейчас есть настройка pause.global: если она true, все экшены останавливаются   (done)
на паузе, если false - никакие не останавливаются, и можно там дальше в коде нужных экшонов предусмотреть, влияет ли на
исполнение пауза или нет. Мб вынести эту логику на уровень движка, чтобы были actionNoPause и обычные. Тогда можно
настройку pause.global выкинуть.
--
Аналогично можно предусмотреть влияние паузы на рендеры и на нажатие клавиш.

drawPolygon не имеет параметра color, ай-я-яй (done)
--
орлы? тащем-та просто не было метода, принимающего List в качестве аргумента. Аналогично допилил для drawFilledPolygon

принудительный показ ололологотипа движка (done)

аналогично drawPoints - drawLines (done)

написать апи для проигрывания анимации
--
надо сначала подумать, как бы такое апи могло выглядеть. Хотя можно, как я обычно делаю: написать под определенные нужды,
и если в следующем приложении написанного не хватат, допиливать под него итд.
--
предварительно соснул хуйцов. предложенный вариант апи менее гибкий, чем текущий, через переменную current_frame,
один экшон и один рендер. Надо этот юзкейс как-то весь годно формализовать в один периодический метод.

мелкие оптимизации:
метод removeTrace/removeTraceById (один типа, чтобы не было лишнего foreach), итд
--
тогда и для экшонов что ли такое пилить? я ебанусь же.

подумать на досуге о возможности переполнения айдишников и возможном замедлении работы при логировании
их генерации (в режиме дебаг, при добавлении новых трейсов, например)

начать ботать Java Web Start. В перспективе это должно стать профилем в pom.xml (done)
--
крутота!

новый метод в трейсере: removeTraceByPoint/removeTraceByCoord
--
необходимость пока под вопросом

сообщение в логе при постановке/снятии с паузы (done)
--
нужно например за тем, чтобы иметь возможность все же отслеживать состояние "на паузе/не на паузе", даже
если в интерфейсе это нигде не отображается никак (клиентский разработчик может в программе нигде не помечать состояние паузы)

outsidePoint(...) -> point(...)
--
нее: метод point из CoordTracer перенести в ScageTracer (done)

мб переписать методы типа drawPolygon итд, принимающие произвольное количество координат: сначала цвет,
потом координаты. Это избавит от дополнительного метода (вроде)

допилить drawPoint чтобы принимал список точек (done)
--
метод drawPoints


В ScageMessage добавить методы принимающие Vec вместо float, float
--
дописать в ScageMessage методы print*, принимающие Vec

сделать клавишу "any key" =) (done)

Возможность задания периодичности работы action'ов by-value значением, то есть возможность менять ее на ходу  (done)
--
Сделано. Оставлен предыдущий вариант - статичный период между выполнением action'ов: actionWithStaticPeriod
Благодаря опциям компилятора он даже может быть немножко оптимизированный..)

Возможность передавать State в событийном фреймворке в ScageScreen
--
снабдить логами событийный фреймворк

мб все настройки, начальные параметры вывести в *.properties. Тогда все можно переписать трейтами..
--
тогда будут траблы, если например в клиентском приложении требуется два трейсера в одном классе итд
и вообще, трейт - это если все-таки нужны какие то абстрактные методы

trait ScageTracer
--
фейл. Нельзя иметь одноименные trait и класс. Так что уж лучше класс

Trace extends State
просто и гениально :3
--
свои подводны камни тут тоже есть. Вызов getState начитывал каждый раз в State нужные параметры, и таким образом их
актуальность гарантировалась. Сейчас ничего такого не гарантируется. Более того, любой может сделать любой put в trace!
--
Полный фейл. Устранение подводных камней чересчур усложняет код движка. Откатываюсь назад

pointMatrix --> createMatrix   (done)
--
удалил совсем
--
запилил initMatrix

продумать еще раз добавление action от условий:
условие выполнения action, или период между выполнениями, условие удаления. события при удалении... (done)
--
реализовал просто период между выполнениями, но он может динамически меняться

----------------

RoadMap
v0.5
* physics перенести в support, сделать по аналогии с tracer. До меня внезапно дошло, что в чем-то эти две
структуры весьма схожи. (done)
* переименовать --> в более простое addPhysical (done)
* newtracer перенести в tracer, tracer удалить (done)
* Переименовать базовый класс Tracer в ScageTracer (done)
* В tracer в функции traces добавить отдельные аргументы rangex и rangey (вместо общего range по обоим осям
сейчас) (done)
* Также добавить функцию, возвращающую объекты только с заданной точки (done)
* Поправить баг в updateLocation - если trace.id не был добавлен и не существует в traces_in_coord (done)
* В Renderer в методы draw* добавить аргумент _color, равный по умолчанию текущему цвету. (done)
* добавить функционал по вводу строк (отдельное окошко на свинге с простым текстовым полем, ввод по ctrl-enter)
* Добавить метод, рисующий точку (хочу себе навороченный бейсик)) (done)
* сообщения в логах при удалении операций из ScageScreen (done)

----------------

В движке есть следующие компоненты:
ScageScreen
Controller + Renderer + ScageColors + Keyboard + Mouse
ScageProperties
ScageMessages
NetServer + NetClient
Tracer
ScagePhysics
Постараться, чтобы они не зависили друг от друга, чтобы каждый из этих комопнентов можно было использовать отдельно от
движка.
--
мб допилить, чтобы можно было все параметры задавать как параметры (некоторые сейчас можно только через
файл .properties)

есть operation_id - для скринов и рендеров, есть trace_id - для трейсов и есть disaplylist_key - для дисплейных списков.
последний начинается с 10000 в качестве воркэраунда для одного шняги. Код практически одинаковый.
Мб сделать единый счетчик для всего вообще.              (done)
--
и перефигачить в Long
--
сделано. Long не удалось из-за дисплейных списокв

main screen - сделать единственным в системе, или оставить текущее положение? Вариант ТЗ:
при создании объекта ScageScreen в качестве параметра передавать имя. Первый созданный скрин станет main, для него
будут начитаны переданные проперти. Если проперти не переданы, пытаемся прочитать файл "имя скрина".toLower+".properties"
Главный скрин сейчас по сути - если для него вызвать stop, закрывать программу полностью. В принципе можно сделать программу
без мейн скрина (все скрины - не мейн), и программу с несколькими мейнами. Только смысл? Аналогично с пропертями: можно
переначитывать разные файлы несколько раз в программе в зависимости от. Другое дело, что это можно сделать и безотносительно
к системе скринов..
В общем, первый запущенный скрин становится мейном. Мейн в приложении может быть только один. Если мейн закрылся, приложение
в целом тоже. Относительно мейна начитываются проперти
--
переусложнения и ненужные ограничения, пока отказался

система эвентов в ScageScreen: onEvent(HERO_DIES) {...}, callEvent(HERO_DIES) итд     (done)
--
реализовал, но пока так и не придумал, где это применить. Коды эвентов - строковые константы

удалять рендеры (мб и контролы)      (partly-done)
--
сделал удаление рендеров. про контролы пока непонятно, нужно ли

su.msk.dunno -> net.eredory

продумать:
  * поставку в виде web start
  * поставку в виде апплета
  * продумать сетевой режим через интернет

В общем, мб все отдельные сущности поставлять в двух видах: синглтонами и классами
Например, ScageMessages - классом, чтобы можно было в одном приложении юзать разные шрифты разных размеров итд

Также мб сделать реализации некоторых вещей сразу встроенными в скрины (типа ФизиксСкрин, НетСкрин)
Возможно, что-то можно сделать также трейтами, чтобы еще удобнее было собирать приложение как конструктор
из компонентов

сделать сетевые сущности синглтонами или классами?
  плюсы синглтонов: удобнее синтаксис, можно статически импортить содержимое NetServer/NetClient, и сразу писать
  предметный код, не создавая никаких объектов. Также, более чистенько выглядит взаимодействие
  NetServer - ClientHandler (не надо соображать, выносить ли порт, макс_клиентс, и чек_таймаут в отдельный
  объект, начитывать из файла, или задавать параметром для каждого класса НетСервер и передавать
  клиентхэндлеру нужный ему чек_таймаут...)

  плюсы классов: шире возможности. Можно создавать много разных серверов и клиентов на разных портах и работать
  со всеми одновременно. Вопрос, нужно ли это. Ладно, если будет нужно, перепишу.

запилить режим работы без графики

сделать нормальный общий Logger, который принимает by-name параметры и делает проверку isDebugEnabled итд
--
подумать над вменяемым, красивым и производительным логированием
--
добавить в него возможность продолжать писать лог на той же строке

переименовать в Renderer: createDisplayList -> image, createAnimation -> animation (done)

Раз уж удаление операций вроде фурычит, мб придумать какой-нить механизм самоудаления операций... (done)
--
сделал метод currentOperaion в объекте ScageScreen - возвращает id текущей операции. Таким образом операция может
прочитать его и удалить, удалив таким образом себя

в ScageScreen добавить функции, принимающие списки айдишников операций и удаляющие соотв операции (done)

придумать dsl для парсинга State
--
Нужен более простой синтакисис работы с классом State. JSON-like стиль в целом хорош, но тоже может стать болью в
заднице, когда мы спускаемся на более низкие уровни вложенности. Кроме того нужно продумать задание правил и
зависимостей между значениями внутри State (возможно не в рамках Scage, возможно только в Blamer)

дописать в tracer методы, возвращающие случайные координаты (done)
--
добавить в randomPoint/randomCoord условие, по которому производить генерацию
--
подумал и решил, что это лишнее, потому что скорость работы этих функций более не будет гарантированной
лучше решать проблему отсеивания нужных случайных позиций средствами клиентского приложения (как в Snake)

дальнейший рефакторинг: избавиться от пакета single, перенеся все из него в support и еще куда надо. Пакет screens
cтановится единственным, и его можно поднять на уровень вверх - su.msk.dunno.scage

начать писать комментарии в формате javadoc

Мб объединить генерацию дисплейных списокв в UnicodeFont с генерацией в Renderer, для остальной части Scage
--
сложновато

еще раз продумать апи physics
--
Вообще, тут не надо думать, тут просто прогать надо, кучу разных проектов, где задействован физический движок. По мере
прояснения, что и где требуется и как применять, будет яснее и насчет ТЗ на апи.

доделать drawPolygon и drawFilledPolygon    (done)
--
не помню, что я там хотел доделать, но наверное доделал, пушо сейчас к этому апи претензий нет

Реализовать механизм ввода текстовой информации
--
окошко свинговое с текстовым полем

Переделать Tracer, чтобы сам вычислял где какой трейс лежит (хранил мап) (done)

Мб завести иерархию файлов строк, которые читает движок при запуске, или просто на этапе сборки мавеном начитывать в один
файл из умолчальных файлов и из application-specific.

Поправить взаимодействие Renderer со ScageScreen в случае, когда мы - main_screen (done)

Переделать цветные строки

Апдейт пропертей: возможность задавать цвета, а также векторные величины (из двух значений)
--
возможность задавать цвета сейчас реализована следующим образом: в ScageColors впилен метод, принимающий имя цвета
и отдающий цвет (задействована такая-то крутая рефлексия)

Мб все-таки хранить файлы resources внутри джарника программы, как все крутые пацаны делают (done)
--
аналогично мб проперти (done)
--
это адово необходимо, когда у нас webstart например

Надо разработать план по описанию движка Scage: словесное описание, примеры кода, готовые приложения разные, куча
картинок. Подробное описание способов быстрого создания нового проекта (через мавеновский архетип), сборки готового
приложения. Все это на русском, потом на английский перевести (как можно быстрее).

Добавить поддержку мышки в Controller (done)

возможность определять проперти через другие проперти
name = $app_name - $version

Надо продумать возможность перезапуска игры связкой exit - init, или просто init, чтобы можно было все грамотно
инициализировать - в частности, для физического движка чтобы все работало  (done)
